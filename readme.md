## 一致性hash算法

hash算法取余这种方式有一个坏处就是当增加或者减少的节点的时候都会带来需要重新hash，之前的hash缓存之类的都会失效。

之后就提出了一致性hash算法，就是先构造一个**2的32次方**的整数环，根据每次hash值都放在这个hash环上面，根据hash的值查找距离，放在理服务器最近的服务节点上面，完成映射。



### 实现方式

hash环的实现方式有几种：

1. list+排序

   > 这种方式每次只要查找到大于list中hash值的就可以停止，每次查找的效率最少是O(1)，至多是O(n)；所以时间复杂度为O(n)

2. 纯list不排序

   > 这种方式的话需要轮询所有的，然后记录所有比他大的值；一遍轮询下来，然后比较其中最小的，时间复杂度为O(n)，如果没有比他大的，那就是需要再轮询一遍找到最大的，就是O(n)+O(n)。最终复杂度为O(n)

3. TreeMap的方式

   > 因为树的结构，所以它每次查找的效率为O(logn)的复杂度，最为方便；但是为了维护内部的红黑树，所以插入的效率就慢很多了。



### 具体实现

这边我已经实现了相关的代码，放在github上了。

一致性hash算法实现：https://github.com/easonzrq/consistentHash/tree/master/.idea